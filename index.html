<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典貪吃蛇 - 彩色漸層版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            background: radial-gradient(circle, #1a202c 0%, #0d1117 100%);
            overscroll-behavior: none;
        }
        canvas {
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 70vh;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(16, 185, 129, 0.2);
        }
        .control-btn {
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen text-white font-sans overflow-hidden">

    <!-- 標題與分數資訊 -->
    <div class="mb-4 text-center">
        <h1 class="text-4xl font-black mb-2 tracking-widest bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 via-blue-500 to-purple-500">SNAKE</h1>
        <div class="flex gap-8 justify-center text-lg font-mono bg-gray-800/50 px-6 py-2 rounded-full border border-gray-700">
            <div>SCORE: <span id="score" class="text-white">0</span></div>
            <div>BEST: <span id="highScore" class="text-emerald-400">0</span></div>
        </div>
    </div>

    <!-- 遊戲畫布 -->
    <div class="relative">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-lg hidden">
            <h2 class="text-3xl font-bold mb-4 text-red-500">GAME OVER</h2>
            <button onclick="resetGame()" class="bg-emerald-500 hover:bg-emerald-600 text-black font-bold py-2 px-8 rounded-full transition-all active:scale-95">
                RESTART
            </button>
        </div>
    </div>

    <!-- 行動裝置控制鈕 -->
    <div class="mt-8 grid grid-cols-3 gap-2 md:hidden">
        <div></div>
        <button id="btnUp" class="control-btn w-16 h-16 bg-gray-700/50 rounded-xl flex items-center justify-center active:bg-emerald-500">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
        </button>
        <div></div>
        <button id="btnLeft" class="control-btn w-16 h-16 bg-gray-700/50 rounded-xl flex items-center justify-center active:bg-emerald-500">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
        </button>
        <button id="btnDown" class="control-btn w-16 h-16 bg-gray-700/50 rounded-xl flex items-center justify-center active:bg-emerald-500">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
        </button>
        <button id="btnRight" class="control-btn w-16 h-16 bg-gray-700/50 rounded-xl flex items-center justify-center active:bg-emerald-500">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
        </button>
    </div>

    <p class="mt-6 text-gray-500 text-sm hidden md:block">使用鍵盤方向鍵來控制移動</p>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const overlay = document.getElementById('overlay');

        const gridSize = 20;
        let tileCountX, tileCountY;
        
        let snake = [];
        let food = { x: 5, y: 5 };
        let dx = 0, dy = 0;
        let nextDx = 0, nextDy = 0;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoop;
        let lastTime = 0;

        // 速度參數
        const BASE_SPEED = 5;     
        const SPEED_INCREMENT = 0.5; 
        const SCORE_PER_LEVEL = 30; 
        let currentSpeed = BASE_SPEED;

        function init() {
            const width = Math.min(window.innerWidth - 40, 400);
            const height = Math.min(window.innerHeight * 0.5, 400);
            
            canvas.width = Math.floor(width / gridSize) * gridSize;
            canvas.height = Math.floor(height / gridSize) * gridSize;
            
            tileCountX = canvas.width / gridSize;
            tileCountY = canvas.height / gridSize;

            highScoreDisplay.innerText = highScore;
            resetGame();
        }

        function resetGame() {
            snake = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) + 1 },
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) + 2 }
            ];
            dx = 0; dy = -1;
            nextDx = 0; nextDy = -1;
            score = 0;
            currentSpeed = BASE_SPEED;
            scoreDisplay.innerText = score;
            overlay.classList.add('hidden');
            placeFood();
            
            lastTime = 0;
            if (gameLoop) cancelAnimationFrame(gameLoop);
            gameLoop = requestAnimationFrame(update);
        }

        function placeFood() {
            food.x = Math.floor(Math.random() * tileCountX);
            food.y = Math.floor(Math.random() * tileCountY);
            if (snake.some(part => part.x === food.x && part.y === food.y)) {
                placeFood();
            }
        }

        function update(currentTime) {
            gameLoop = requestAnimationFrame(update);
            
            if (!lastTime) lastTime = currentTime;
            const secondsSinceLastRender = (currentTime - lastTime) / 1000;
            
            if (secondsSinceLastRender < 1 / currentSpeed) return;
            lastTime = currentTime;

            dx = nextDx;
            dy = nextDy;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                return gameOver();
            }

            if (snake.some(part => part.x === head.x && part.y === head.y)) {
                return gameOver();
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreDisplay.innerText = score;
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.innerText = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }
                currentSpeed = BASE_SPEED + (Math.floor(score / SCORE_PER_LEVEL) * SPEED_INCREMENT);
                placeFood();
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            // 背景
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 背景裝飾線
            ctx.strokeStyle = '#1a202c';
            ctx.lineWidth = 1;
            for (let i = 0; i <= canvas.width; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
            }

            // 食物
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f87171';
            ctx.fillStyle = '#f87171';
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // 繪製蛇 (彩色漸層)
            snake.forEach((part, index) => {
                const isHead = index === 0;
                
                // 根據索引計算色相 (0-360)
                // 每個節點偏離 15 度，讓漸層看起來很順滑
                const hue = (index * 15) % 360; 
                ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                
                // 如果是頭部，增加一點亮度區分
                if (isHead) ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;

                const x = part.x * gridSize + 1;
                const y = part.y * gridSize + 1;
                const size = gridSize - 2;
                
                ctx.beginPath();
                ctx.roundRect(x, y, size, size, isHead ? 6 : 4);
                ctx.fill();

                if (isHead) {
                    // 繪製眼睛
                    ctx.fillStyle = 'white';
                    const eyeSize = 3;
                    if (dx === 1) { // 右
                        ctx.fillRect(x + size - 6, y + 4, eyeSize, eyeSize);
                        ctx.fillRect(x + size - 6, y + size - 7, eyeSize, eyeSize);
                    } else if (dx === -1) { // 左
                        ctx.fillRect(x + 3, y + 4, eyeSize, eyeSize);
                        ctx.fillRect(x + 3, y + size - 7, eyeSize, eyeSize);
                    } else if (dy === -1) { // 上
                        ctx.fillRect(x + 4, y + 3, eyeSize, eyeSize);
                        ctx.fillRect(x + size - 7, y + 3, eyeSize, eyeSize);
                    } else { // 下
                        ctx.fillRect(x + 4, y + size - 6, eyeSize, eyeSize);
                        ctx.fillRect(x + size - 7, y + size - 6, eyeSize, eyeSize);
                    }
                }
            });
        }

        function gameOver() {
            cancelAnimationFrame(gameLoop);
            overlay.classList.remove('hidden');
        }

        window.addEventListener('keydown', e => {
            if (overlay.classList.contains('hidden')) {
                switch(e.key) {
                    case 'ArrowUp': if (dy !== 1) { nextDx = 0; nextDy = -1; } break;
                    case 'ArrowDown': if (dy !== -1) { nextDx = 0; nextDy = 1; } break;
                    case 'ArrowLeft': if (dx !== 1) { nextDx = -1; nextDy = 0; } break;
                    case 'ArrowRight': if (dx !== -1) { nextDx = 1; nextDy = 0; } break;
                }
            } else if (e.key === 'Enter') {
                resetGame();
            }
        });

        const setDir = (nx, ny) => {
            if ((nx !== 0 && dx !== -nx) || (ny !== 0 && dy !== -ny)) {
                nextDx = nx; nextDy = ny;
            }
        };

        document.getElementById('btnUp').onclick = () => setDir(0, -1);
        document.getElementById('btnDown').onclick = () => setDir(0, 1);
        document.getElementById('btnLeft').onclick = () => setDir(-1, 0);
        document.getElementById('btnRight').onclick = () => setDir(1, 0);

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
