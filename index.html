<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>打磚塊遊戲</title>
<style>
body { margin:0; padding:0; text-align:center; font-family: Arial, sans-serif; background: linear-gradient(to bottom,#cce7ff,#ffffff);}
canvas { background: #eee; display:block; margin: 10px auto; touch-action: none; border-radius: 10px; }
button { margin: 10px; padding: 14px 28px; font-size: 20px; border-radius:8px; background:#0095DD; color:#fff; border:none; cursor:pointer; }
button:active { background:#007bb5; }
h1 { font-size: 32px; }
p { font-size: 20px; }
</style>
</head>
<body>
<h1>打磚塊遊戲</h1>
<!---<p>打中磚塊 → 玩具震動 🚀<br>輸掉遊戲 → 強度100，時間30秒<br>勝利時 → 連續短震慶祝<br>分數超過30後球速逐步增加</p>--->
<canvas id="myCanvas"></canvas>
<button id="connectBtn">連線藍牙玩具</button>

<script>
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

// 手機自適應
canvas.width = window.innerWidth * 0.95;
canvas.height = window.innerHeight * 0.5;

// 遊戲設定
let ballRadius = 12; // 球稍大
let x = canvas.width/2;
let y = canvas.height-30;
let baseSpeed = 2;
let dx = baseSpeed;
let dy = -baseSpeed;
let paddleHeight = 20;
let paddleWidth = canvas.width*0.25; // paddle大一些
let paddleX = (canvas.width-paddleWidth)/2;

// 磚塊設定
let brickPadding = 12;
let brickOffsetTop = 40;
let brickOffsetLeft = 20;
let brickRowCount = 6; 
let brickColumnCount = Math.floor((canvas.width - 40) / (80 + brickPadding));
let brickWidth = (canvas.width - 40 - (brickColumnCount-1)*brickPadding)/brickColumnCount;
let brickHeight = 30; // 高度加大
let score = 0;

let bricks=[];
function initBricks(){
  bricks = [];
  for(let c=0;c<brickColumnCount;c++){
    bricks[c]=[];
    for(let r=0;r<brickRowCount;r++){
      bricks[c][r]={x:0, y:0, status:1, row:r};
    }
  }
}
initBricks();

// 鍵盤控制
let rightPressed=false;
let leftPressed=false;
document.addEventListener("keydown",e=>{
  if(e.key==="Right"||e.key==="ArrowRight") rightPressed=true;
  else if(e.key==="Left"||e.key==="ArrowLeft") leftPressed=true;
});
document.addEventListener("keyup",e=>{
  if(e.key==="Right"||e.key==="ArrowRight") rightPressed=false;
  else if(e.key==="Left"||e.key==="ArrowLeft") leftPressed=false;
});

// 手指拖動 paddle
canvas.addEventListener('touchstart', e=>{
  let touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  paddleX = touchX - paddleWidth/2;
});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  let touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  paddleX = touchX - paddleWidth/2;
  if(paddleX<0) paddleX=0;
  if(paddleX>canvas.width-paddleWidth) paddleX=canvas.width-paddleWidth;
}, {passive:false});

// Lovense 控制 & Web Bluetooth
let bluetoothDevice=null;
let bluetoothCharacteristic=null;
const connectBtn=document.getElementById('connectBtn');
connectBtn.addEventListener('click',async ()=>{
  try{
    bluetoothDevice=await navigator.bluetooth.requestDevice({filters:[{namePrefix:'Lovense'}], optionalServices:['0000xxxx-0000-1000-8000-00805f9b34fb']});
    const server=await bluetoothDevice.gatt.connect();
    const service=await server.getPrimaryService('0000xxxx-0000-1000-8000-00805f9b34fb');
    bluetoothCharacteristic=await service.getCharacteristic('0000yyyy-0000-1000-8000-00805f9b34fb');
    alert('藍牙玩具已連線！');
  }catch(e){console.log(e); alert('藍牙連線失敗');}
});

async function vibrateToy(sec,strength){
  strength=Math.min(strength,100);
  try{await fetch("http://127.0.0.1:30010/command",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({command:"Function",action:"Vibrate",timeSec:sec,strength:strength})});} 
  catch(e){console.log(e);}
  if(bluetoothCharacteristic){try{await bluetoothCharacteristic.writeValue(Uint8Array.of(strength,sec));}catch(e){console.log(e);}}
}

// 勝利連續短震
async function celebrateVictory(times=5, sec=0.5){
  for(let i=0;i<times;i++){
    let strength=Math.min(5+score,50);
    vibrateToy(sec,strength);
    await new Promise(resolve=>setTimeout(resolve, sec*1000+100));
  }
}

function collisionDetection(){
  for(let c=0;c<brickColumnCount;c++){
    for(let r=0;r<brickRowCount;r++){
      let b=bricks[c][r];
      if(b.status===1 && x>b.x && x<b.x+brickWidth && y>b.y && y<b.y+brickHeight){
        dy=-dy;
        b.status=0;
        score++;
        vibrateToy(1,Math.min(5+score,50));

        // 球速增加
        if(score>30){
          dx *= 1.02;
          dy *= 1.02;
        }

        if(score===brickRowCount*brickColumnCount){
          alert("你贏了！");
          celebrateVictory();
          document.location.reload();
        }
      }
    }
  }
}

function drawBall(){ctx.beginPath(); ctx.arc(x,y,ballRadius,0,Math.PI*2); ctx.fillStyle="#0095DD"; ctx.fill(); ctx.closePath();}
function drawPaddle(){ctx.beginPath(); ctx.roundRect(paddleX,canvas.height-paddleHeight,paddleWidth,paddleHeight,10); ctx.fillStyle="#0095DD"; ctx.fill(); ctx.closePath();}
function drawBricks(){for(let c=0;c<brickColumnCount;c++){for(let r=0;r<brickRowCount;r++){let b=bricks[c][r]; if(b.status===1){let brickX=(c*(brickWidth+brickPadding))+brickOffsetLeft; let brickY=(r*(brickHeight+brickPadding))+brickOffsetTop; b.x=brickX;b.y=brickY; ctx.beginPath(); ctx.roundRect(brickX,brickY,brickWidth,brickHeight,6); let colorValue=50+r*20; ctx.fillStyle=`rgb(${colorValue},100,${255-colorValue})`; ctx.fill(); ctx.closePath();}}}}
function drawScore(){ctx.font="24px Arial"; ctx.fillStyle="#0095DD"; ctx.fillText("分數: "+score,10,30);}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawScore();
  collisionDetection();

  if(x+dx>canvas.width-ballRadius||x+dx<ballRadius) dx=-dx;
  if(y+dy<ballRadius) dy=-dy;
  else if(y+dy>canvas.height-ballRadius){
    if(x>paddleX && x<paddleX+paddleWidth) dy=-dy;
    else{alert("遊戲結束"); vibrateToy(30,100); document.location.reload();}
  }

  if(rightPressed && paddleX<canvas.width-paddleWidth) paddleX+=7;
  else if(leftPressed && paddleX>0) paddleX-=7;

  x+=dx; y+=dy;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
